---
title: Proyecto de Clasificación de Voces de Personas
author:
  - name: Luis Albacete Caballero
    email: alcaluis@alumni.uv.es
    affiliation: UV
  - name: Julio García Bustos
    email: jugarbus@alumni.uv.es
    affiliation: UV
  - name: Gabriel Ivars Asensio
    email: bob@example.com
    affiliation: UV
  - name: Noé López García
    email: bob@example.com
    affiliation: UV
  - name: José Miguel Palazón Caballero
    email: bob@example.com
    affiliation: UV
  - name: Joan Pedro Bruixola
    email: jopebrui@alumni.uv.es
    affiliation: UV
address:
  - code: UV
    organization: Universitat de València
    addressline: Avinguda de l'Universitat
    city: Burjassot
    state: Valencia
    postcode: 46100
    country: España
abstract: |
  Esto es un ejemplo de texto en la sección "Abstract".
keywords: 
  - Voces
  - Características
  - Características de la voz
  - Clasificación
  - Aprendizaje Máquina
  - Análisis de Señales
  - Identificación voces
date: "`r Sys.Date()`"
linenumbers: false
numbersections: true
output: 
  rticles::elsevier_article:
    keep_tex: true
    citation_package: natbib
---

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE,
                      #warning=FALSE,
                      out.width = "80%",
                      fig.align = "center")

# Cargar librerías
librerias <- c("tuneR",    # Lectura de archivos WAV
               "seewave"   # Manipulación mediante wavelets
              )
pacman::p_load(char = librerias)

# Cargar utilidades
source("../Utils/extraccion_caracteristicas.R")
source("../Utils/carga_datos.R")
```

```{r limpieza_audios}
# Cargar datos + Metadatos
# w <- readWave("../Data/whatstheweatherlike.wav") # Audio ejemplo
carga <- carga_audios("../Data/Audios/")
audios <- carga[[1]]
meta_audios <- carga[[2]]

library(wavelets)

# 1. Eliminación ruido
audios <- limpieza_senales(audios)

# 2. Normalización
audios <- normalizacion(audios)

# 3. DataFrame características
df_caract <- data.frame("id_audio" = meta_audios$id_audio)
```

# Característica de la voz

## Característica ejemplo

```{r extraccion_caract_ejemplo}
# WIP
ste_c <- rep(0.0, length(audios))
id <- 1

for (audio in audios) {
  ste_c[id] <- mean(STE(audio, audio@samp.rate * 0.02, 50)[,2])
  id = id + 1
}

# Agregar caracteristica
df_caract <- cbind(df_caract, ste_c)
```

## Característica 1

```{r extraccion_caract_1}
# WIP
```

## Característica SH

```{r extraccion_caract_SH}
# SH
# Inicializar el vector para la característica ZCR
SH_carac <- rep(0.0, length(audios))

# ID para iterar sobre los audios
id <- 1

audios_sin_normalizar <- carga[[1]]

# 1. Eliminación ruido
audios_sin_normalizar <- limpieza_senales(audios_sin_normalizar)

for (audio in audios_sin_normalizar) {
  # Acceso directo a los canales izquierdo y derecho
  audio_iz <- audio@left
  audio_de <- audio@right
  
  # Calcular FO para cada canal
  SH_iz <- SH(audio_iz)
  SH_de <-SH(audio_de)
  
  # Promediar los valores calculados
  SH_carac[id] <- mean(c(SH_iz, SH_de))
  # Incrementar el contador
  id <- id + 1
}

#Normalizados
SH_carac_norm <- rep(0.0, length(audios))

id <- 1

for (audio2 in audios) {
  # Acceso directo a los canales izquierdo y derecho
  audio_iz <- audio2@left
  audio_de <- audio2@right
  
  # Calcular FO para cada canal
  SH_iz <- SH(audio_iz)
  SH_de <-SH(audio_de)
  
  # Promediar los valores calculados
  SH_carac_norm[id] <- mean(c(SH_iz, SH_de))
  # Incrementar el contador
  id <- id + 1
}

# Agregar la característica ZCR al marco de datos
df_caract <- cbind(df_caract, SH_carac)
df_caract <- cbind(df_caract, SH_carac_norm)
```



```{r}
ggplot(df, aes(x = SH_carac, fill = genero)) +
  geom_density(alpha = 0.5) +  # Curvas de densidad
  labs(
    title = "Distribución de SH por Género sin Normalizar",
    x = "SH",
    y = "Densidad",
    fill = "Género"
  ) +
  theme_minimal()

ggplot(df, aes(x = SH_carac_norm, fill = genero)) +
  geom_density(alpha = 0.5) +  # Curvas de densidad
  labs(
    title = "Distribución de SH por Género y Normalizados",
    x = "SH",
    y = "Densidad",
    fill = "Género"
  ) +
  theme_minimal()


```


```{r}
ggplot(df, aes(x = locutor, y = SH_carac, color = genero)) +
  geom_point(size = 3, alpha = 0.8) +  # Puntos
  geom_boxplot(aes(group = genero), alpha = 0.3, outlier.shape = NA) +  # Boxplots por género
  labs(
    title = "SH por Locutor y Género sin Normalizar",
    x = "Locutor",
    y = "SH",
    color = "Género"
  )  +  
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

## Característica PLP

```{r extraccion_caract_PLP}
# Guardamos cada coeficiente de la salida como una columna nueva excluyendo el primer coeficiente pues siempre es 0
num_features <- 14
PLP_matrix <- matrix(0, nrow = length(audios), ncol = num_features-1)

id <- 1

for (audio in audios) {
  # Calcular PLP para cada canal
  PLP_iz <- rowMeans(PLP(audio, wlen = 256, ovlp = 70, side = 'l'))
  PLP_de <- rowMeans(PLP(audio, wlen = 256, ovlp = 70, side = 'r'))
  
  # Promediar los valores calculados
  PLP_med <- (PLP_iz + PLP_de) / 2
  
  PLP_matrix[id, ] <- PLP_med[-1]  # Primer coeficiente siempre 0

  id <- id + 1
}

colnames(PLP_matrix) <- paste0("PLP_c", 2:num_features)

# Combinar el nuevo marco de datos con el original
df_caract <- cbind(df_caract, PLP_matrix)

# Verificar el resultado
print(head(df_caract))

```



```{r}
# Caracteristica PLP como lista para almacenar el vector en una columna
PLP_carac <- vector("list", length(audios))

id <- 1

for (audio in audios) {
  # Calcular PLP para cada canal
  PLP_iz <- rowMeans(PLP(audio, wlen = 256, ovlp = 70, side = 'l'))
  PLP_de <- rowMeans(PLP(audio, wlen = 256, ovlp = 70, side = 'r'))
  
  # Promediar los valores calculados
  PLP_med <- (PLP_iz + PLP_de) / 2
  
  # Almacenar el resultado en la lista
  PLP_carac[[id]] <- PLP_med
  
  # Incrementar el contador
  id <- id + 1
}

# Si PLP_carac es una lista de vectores, agrégala correctamente al marco de datos
df_caract$PLP_carac <- PLP_carac

```




# Algoritmos de ML

## Clustering

```{r algoritmos_clustering}
# WIP
```

## Clasificación

```{r algoritmos_clasificacion}
# WIP
```



